<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Flappy Bird 道具版</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- 使用 Inter 字体 -->
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            background-color: #1f2937; /* Dark background */
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            user-select: none;
        }
        #game-container {
            width: 100%;
            max-width: 480px; /* Max width for mobile-friendly view */
            height: 90vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            position: relative;
            background-color: #374151; /* Card background */
            border-radius: 1rem;
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.3), 0 8px 10px -6px rgba(0, 0, 0, 0.2);
            padding: 1rem;
        }
        #gameCanvas {
            border: 4px solid #4b5563;
            border-radius: 0.5rem;
            background: linear-gradient(to bottom, #7dd3fc 0%, #3b82f6 100%); /* Sky gradient */
            box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.5);
            touch-action: manipulation; /* Prevents double-tap zoom on mobile */
        }
        .ui-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            background-color: rgba(0, 0, 0, 0.7);
            border-radius: 1rem;
            text-align: center;
            z-index: 10;
            color: white;
            padding: 20px;
        }
        .game-button {
            padding: 0.75rem 1.5rem;
            margin-top: 1rem;
            font-size: 1.25rem;
            font-weight: bold;
            color: #1f2937;
            background-color: #fcd34d;
            border: 3px solid #b45309;
            border-radius: 9999px;
            cursor: pointer;
            transition: all 0.1s;
            box-shadow: 0 4px #b45309;
        }
        .game-button:hover {
            background-color: #facc15;
            box-shadow: 0 2px #b45309;
            transform: translateY(2px);
        }
        .game-button:active {
            box-shadow: none;
            transform: translateY(4px);
        }
        .score-display {
            color: white;
            font-size: 2.5rem;
            font-weight: 700;
            margin-bottom: 0.5rem;
            text-shadow: 2px 2px #000;
        }
        .powerup-indicator {
            position: absolute;
            top: 10px;
            right: 10px;
            padding: 8px 16px;
            background-color: rgba(255, 255, 255, 0.9);
            color: #1f2937;
            font-weight: bold;
            border-radius: 0.5rem;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            transition: opacity 0.3s;
        }
    </style>
</head>
<body>

<div id="game-container">
    <div id="scoreDisplay" class="score-display">分数: 0</div>
    <div id="powerupIndicator" class="powerup-indicator hidden opacity-0"></div>
    <canvas id="gameCanvas" width="450" height="600"></canvas>

    <div id="startScreen" class="ui-overlay">
        <h1 class="text-4xl font-bold mb-4">道具飞鸟 (Flappy PowerUp)</h1>
        <p class="text-lg mb-6">点击或按空格键跳跃。</p>
        <p class="text-lg mb-8">收集道具：<span style="color: #fcd34d;">⭐</span> 无敌 | <span style="color: #60a5fa;">⏱️</span> 慢动作</p>
        <button id="startButton" class="game-button">开始游戏</button>
    </div>

    <div id="gameOverScreen" class="ui-overlay hidden">
        <h1 class="text-5xl font-extrabold text-red-400 mb-4">游戏结束!</h1>
        <p class="text-xl mb-2">最终分数: <span id="finalScore" class="font-bold">0</span></p>
        <p class="text-lg mb-6">最高分数: <span id="highScore" class="font-bold">0</span></p>
        <button id="restartButton" class="game-button">重新开始</button>
    </div>
</div>

<!-- 确保 Tone.js 在模块脚本之前加载 -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/tone/15.3.5/Tone.min.js"></script>

<script type="module">
    // --- Firebase Initialization (Using provided Canvas globals) ---
    import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
    import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
    import { getFirestore, doc, getDoc, setDoc, onSnapshot } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

    // Global Firebase vars (Must be used)
    const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
    const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : {};
    const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;
    
    // Global game vars
    let app, db, auth;
    let userId = null;
    let highScore = 0;
    const HIGH_SCORE_DOC_PATH = `/artifacts/${appId}/public/data/flappy_bird_scores/leaderboard`;

    // --- Sound Setup (Tone.js) ---
    // 将 Tone 引用和音频对象声明为 let，以便在 setupAudio 中初始化
    let Tone = null; 
    let synth = null;
    let noise = null;
    let isAudioSetup = false;

    /**
     * 初始化 Tone.js 库和所有合成器。
     * 只有在用户第一次互动时才会被调用。
     */
    function setupAudio() {
        if (isAudioSetup) return;
        
        if (typeof window.Tone === 'undefined') {
            console.error("Tone.js library not loaded. Audio will be disabled.");
            return;
        }

        // 成功获取全局 Tone 对象并开始初始化
        Tone = window.Tone; 
        
        synth = new Tone.PolySynth(Tone.Synth, {
            oscillator: { type: "square" },
            envelope: { attack: 0.005, decay: 0.1, sustain: 0.0, release: 0.1 }
        }).toDestination();

        noise = new Tone.NoiseSynth({
            noise: { type: "white" },
            envelope: { attack: 0.005, decay: 0.2, sustain: 0.0, release: 0.3 }
        }).toDestination();
        
        isAudioSetup = true;
        Tone.start(); // 恢复音频上下文
    }

    // 所有音频播放函数现在都增加了检查
    function playJumpSound() {
        if (!isAudioSetup) return;
        synth.triggerAttackRelease("C5", "8n");
    }

    function playScoreSound() {
        if (!isAudioSetup) return;
        synth.triggerAttackRelease(["E5", "G5"], "16n", Tone.now(), 0.5);
    }

    function playGameOverSound() {
        if (!isAudioSetup) return;
        noise.triggerAttackRelease("0.5");
        synth.triggerAttackRelease("C3", "4n", Tone.now() + 0.1, 0.8);
    }

    function playPowerUpSound() {
        if (!isAudioSetup) return;
        const now = Tone.now();
        synth.triggerAttackRelease("C6", "32n", now);
        synth.triggerAttackRelease("E6", "32n", now + 0.05);
        synth.triggerAttackRelease("G6", "32n", now + 0.1);
    }

    // --- Game Logic ---
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const startScreen = document.getElementById('startScreen');
    const gameOverScreen = document.getElementById('gameOverScreen');
    const scoreDisplay = document.getElementById('scoreDisplay');
    const finalScoreEl = document.getElementById('finalScore');
    const highScoreEl = document.getElementById('highScore');
    const powerupIndicator = document.getElementById('powerupIndicator');

    let gameStarted = false;
    let gameOver = false;
    let animationFrameId;
    let score = 0;

    // Bird properties
    const bird = {
        x: 50,
        y: canvas.height / 2,
        radius: 12,
        vy: 0,
        gravity: 0.5,
        jumpForce: -8,
        color: '#fcd34d', // Yellow/Gold
        isInvincible: false,
        invincibilityTimer: 0,
        maxInvincibilityTime: 5000, // 5 seconds
        rotation: 0,
        maxRotation: Math.PI / 4 // 45 degrees
    };

    // Pipe properties
    let pipes = [];
    let pipeWidth = 60;
    let pipeGap = 150;
    let pipeSpeed = 3;
    let pipeSpawnInterval = 1500; // ms
    let lastPipeTime = 0;

    // Power-up properties
    let powerUps = [];
    const powerUpSize = 25;
    const POWER_UP_TYPES = {
        STAR: 'STAR', // Invincibility
        CLOCK: 'CLOCK' // Slow Motion
    };
    let slowMotionActive = false;
    let slowMotionTimer = 0;
    const maxSlowMotionTime = 4000; // 4 seconds
    const SLOW_MOTION_FACTOR = 0.5; // Half speed

    // Drawing functions
    function drawBird() {
        ctx.save();
        ctx.translate(bird.x, bird.y);
        ctx.rotate(bird.rotation);
        
        // Draw the bird circle
        ctx.fillStyle = bird.isInvincible ? 'rgba(255, 165, 0, 1)' : bird.color;
        ctx.beginPath();
        ctx.arc(0, 0, bird.radius, 0, Math.PI * 2);
        ctx.fill();

        // Draw the eye (simple dot)
        ctx.fillStyle = 'black';
        ctx.beginPath();
        ctx.arc(bird.radius / 2, -bird.radius / 3, 2, 0, Math.PI * 2);
        ctx.fill();

        // Draw beak (triangle)
        ctx.fillStyle = '#ef4444'; // Red
        ctx.beginPath();
        ctx.moveTo(bird.radius, 0);
        ctx.lineTo(bird.radius + 8, -3);
        ctx.lineTo(bird.radius, 3);
        ctx.fill();

        ctx.restore();
    }

    function drawPipe(pipe) {
        ctx.fillStyle = '#10b981'; // Emerald Green
        // Top pipe
        ctx.fillRect(pipe.x, 0, pipeWidth, pipe.y);
        // Bottom pipe
        ctx.fillRect(pipe.x, pipe.y + pipeGap, pipeWidth, canvas.height - pipe.y - pipeGap);

        // Draw pipe edges for better visuals
        ctx.fillStyle = '#059669'; // Darker Green
        // Top cap for top pipe
        ctx.fillRect(pipe.x - 5, pipe.y - 15, pipeWidth + 10, 15);
        // Top cap for bottom pipe
        ctx.fillRect(pipe.x - 5, pipe.y + pipeGap, pipeWidth + 10, 15);
    }

    function drawPowerUp(powerUp) {
        ctx.save();
        ctx.translate(powerUp.x, powerUp.y);
        
        if (powerUp.type === POWER_UP_TYPES.STAR) {
            // Draw a yellow star
            ctx.fillStyle = '#fcd34d';
            drawStar(ctx, 0, 0, 5, powerUpSize / 2.5, powerUpSize / 5, Math.PI / 2);
        } else if (powerUp.type === POWER_UP_TYPES.CLOCK) {
            // Draw a blue clock emoji/icon
            ctx.font = `${powerUpSize}px sans-serif`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('⏱️', 0, 0);
        }

        ctx.restore();
    }

    // Helper for drawing a star (5 points)
    function drawStar(ctx, cx, cy, spikes, outerRadius, innerRadius, rotation) {
        let rot = rotation;
        let x, y;
        for (let i = 0; i < spikes; i++) {
            x = cx + Math.cos(rot) * outerRadius;
            y = cy + Math.sin(rot) * outerRadius;
            ctx.lineTo(x, y);
            rot += Math.PI / spikes;

            x = cx + Math.cos(rot) * innerRadius;
            y = cy + Math.sin(rot) * innerRadius;
            ctx.lineTo(x, y);
            rot += Math.PI / spikes;
        }
        ctx.closePath();
        ctx.fill();
    }

    // Update functions
    function updateBird(delta) {
        const factor = slowMotionActive ? SLOW_MOTION_FACTOR : 1;
        
        // Apply gravity and update position
        bird.vy += bird.gravity * factor;
        bird.y += bird.vy * factor;

        // Calculate rotation based on velocity
        bird.rotation = Math.min(bird.maxRotation, bird.vy / 10);
    }

    function updatePipes(delta) {
        const factor = slowMotionActive ? SLOW_MOTION_FACTOR : 1;
        
        // Move pipes
        pipes.forEach(pipe => {
            pipe.x -= pipeSpeed * factor;
        });

        // Remove off-screen pipes
        pipes = pipes.filter(pipe => pipe.x > -pipeWidth);

        // Check for scoring
        pipes.forEach(pipe => {
            if (!pipe.passed && pipe.x + pipeWidth < bird.x) {
                pipe.passed = true;
                score++;
                playScoreSound();
                scoreDisplay.textContent = `分数: ${score}`;
            }
        });
        
        // Spawn new pipes
        lastPipeTime += delta;
        if (lastPipeTime > pipeSpawnInterval / factor) {
            createPipe();
            createPowerUp();
            lastPipeTime = 0;
        }
    }

    function updatePowerUps(delta) {
        const factor = slowMotionActive ? SLOW_MOTION_FACTOR : 1;
        
        // Move power-ups
        powerUps.forEach(pu => {
            pu.x -= pipeSpeed * factor;
        });

        // Remove off-screen power-ups
        powerUps = powerUps.filter(pu => pu.x > -powerUpSize);
        
        // Check for bird collection
        powerUps.forEach((pu, index) => {
            if (
                bird.x + bird.radius > pu.x - powerUpSize / 2 &&
                bird.x - bird.radius < pu.x + powerUpSize / 2 &&
                bird.y + bird.radius > pu.y - powerUpSize / 2 &&
                bird.y - bird.radius < pu.y + powerUpSize / 2
            ) {
                // Collision detected, collect power-up
                applyPowerUp(pu.type);
                powerUps.splice(index, 1); // Remove collected power-up
            }
        });

        // Update active power-up timers
        if (bird.isInvincible) {
            bird.invincibilityTimer -= delta;
            updateIndicator(`⭐ 护盾 (${Math.ceil(bird.invincibilityTimer / 1000)}s)`);
            if (bird.invincibilityTimer <= 0) {
                bird.isInvincible = false;
                bird.invincibilityTimer = 0;
                hideIndicator();
            }
        } else if (slowMotionActive) {
            slowMotionTimer -= delta;
            updateIndicator(`⏱️ 慢动作 (${Math.ceil(slowMotionTimer / 1000)}s)`);
            if (slowMotionTimer <= 0) {
                slowMotionActive = false;
                slowMotionTimer = 0;
                hideIndicator();
            }
        }
    }
    
    function updateIndicator(text) {
        powerupIndicator.textContent = text;
        powerupIndicator.classList.remove('hidden', 'opacity-0');
        powerupIndicator.classList.add('opacity-100');
    }

    function hideIndicator() {
        if (!bird.isInvincible && !slowMotionActive) {
            powerupIndicator.classList.add('opacity-0');
            setTimeout(() => {
                powerupIndicator.classList.add('hidden');
            }, 300); // Wait for transition
        }
    }

    function applyPowerUp(type) {
        playPowerUpSound();

        // Cancel existing slow motion/invincibility if a different one is collected
        if (type === POWER_UP_TYPES.STAR) {
            slowMotionActive = false;
            slowMotionTimer = 0;
            bird.isInvincible = true;
            bird.invincibilityTimer = bird.maxInvincibilityTime;
            updateIndicator(`⭐ 护盾`);
        } else if (type === POWER_UP_TYPES.CLOCK) {
            bird.isInvincible = false;
            bird.invincibilityTimer = 0;
            slowMotionActive = true;
            slowMotionTimer = maxSlowMotionTime;
            updateIndicator(`⏱️ 慢动作`);
        }
    }


    // Collision check
    function checkCollision() {
        // 1. Check ground/ceiling collision
        if (bird.y + bird.radius > canvas.height || bird.y - bird.radius < 0) {
            return true;
        }

        // 2. Check pipe collision (only if not invincible)
        if (!bird.isInvincible) {
            for (let pipe of pipes) {
                // Basic AABB check
                const isCollidingX = bird.x + bird.radius > pipe.x && bird.x - bird.radius < pipe.x + pipeWidth;

                if (isCollidingX) {
                    const isCollidingYTop = bird.y - bird.radius < pipe.y; // Top pipe
                    const isCollidingYBottom = bird.y + bird.radius > pipe.y + pipeGap; // Bottom pipe

                    if (isCollidingYTop || isCollidingYBottom) {
                        return true;
                    }
                }
            }
        }
        
        return false;
    }

    // Pipe/Power-up generation
    function createPipe() {
        const minHeight = 50;
        const maxHeight = canvas.height - pipeGap - 50;
        const topPipeHeight = Math.floor(Math.random() * (maxHeight - minHeight) + minHeight);

        pipes.push({
            x: canvas.width,
            y: topPipeHeight,
            passed: false
        });
    }
    
    function createPowerUp() {
        // 1 in 5 chance to spawn a power-up
        if (Math.random() < 0.2) { 
            const puType = Math.random() < 0.5 ? POWER_UP_TYPES.STAR : POWER_UP_TYPES.CLOCK;
            const yPosition = Math.random() * (canvas.height - 2 * powerUpSize) + powerUpSize;
            
            powerUps.push({
                x: canvas.width + pipeWidth * 2, // Spawn ahead of pipes
                y: yPosition,
                type: puType
            });
        }
    }

    // Game state controls
    function resetGame() {
        // Reset bird state
        bird.y = canvas.height / 2;
        bird.vy = 0;
        bird.rotation = 0;
        bird.isInvincible = false;
        bird.invincibilityTimer = 0;
        
        // Reset power-up state
        slowMotionActive = false;
        slowMotionTimer = 0;
        powerupIndicator.classList.add('hidden', 'opacity-0');

        // Reset game state
        score = 0;
        scoreDisplay.textContent = `分数: ${score}`;
        pipes = [];
        powerUps = [];
        lastPipeTime = 0;
        gameOver = false;
        
        // Clear screen and redraw initial state
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        drawBird(); 
    }

    function startGame() {
        gameStarted = true;
        gameOverScreen.classList.add('hidden');
        startScreen.classList.add('hidden');
        resetGame();
        
        // Initialize pipe generation immediately
        createPipe();
        createPowerUp();

        let lastTime = performance.now();
        
        function gameLoop(currentTime) {
            if (gameOver) {
                cancelAnimationFrame(animationFrameId);
                return;
            }

            const delta = currentTime - lastTime;
            lastTime = currentTime;

            // Clear the canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Update
            updateBird(delta / 16.666); // Normalized delta
            updatePipes(delta);
            updatePowerUps(delta);

            // Draw
            pipes.forEach(drawPipe);
            powerUps.forEach(drawPowerUp);
            drawBird();

            // Check collision
            if (checkCollision()) {
                endGame();
                return;
            }

            animationFrameId = requestAnimationFrame(gameLoop);
        }
        
        animationFrameId = requestAnimationFrame(gameLoop);
    }
    
    function endGame() {
        gameOver = true;
        playGameOverSound();
        
        // Update High Score UI
        finalScoreEl.textContent = score;
        if (score > highScore) {
            highScore = score;
            highScoreEl.textContent = highScore;
            saveHighScore(highScore);
        } else {
            highScoreEl.textContent = highScore;
        }

        gameOverScreen.classList.remove('hidden');
    }

    function birdJump() {
        if (!gameStarted || gameOver) return;
        bird.vy = bird.jumpForce;
        playJumpSound();
    }

    // Input handlers
    document.getElementById('startButton').addEventListener('click', () => {
        setupAudio(); // 第一次点击时设置音频
        startGame();
    });
    
    document.getElementById('restartButton').addEventListener('click', startGame);

    canvas.addEventListener('click', () => {
        setupAudio(); // 第一次点击时设置音频
        birdJump();
    });
    canvas.addEventListener('touchstart', (e) => {
        e.preventDefault(); // Prevent scrolling/zoom
        setupAudio(); // 第一次触摸时设置音频
        birdJump();
    });

    document.addEventListener('keydown', (e) => {
        if (e.code === 'Space' || e.key === ' ') {
            e.preventDefault();
            setupAudio(); // 第一次按键时设置音频

            if (gameOver) {
                startGame();
            } else if (gameStarted) {
                birdJump();
            }
        }
    });

    // --- Firebase/High Score Handlers ---

    async function initializeFirebase() {
        if (Object.keys(firebaseConfig).length === 0) {
            console.error("Firebase config is missing. Using local high score storage.");
            // Load local high score if Firebase is not available
            highScore = parseInt(localStorage.getItem('flappyHighScore') || '0', 10);
            highScoreEl.textContent = highScore;
            return;
        }

        try {
            app = initializeApp(firebaseConfig);
            db = getFirestore(app);
            auth = getAuth(app);
            
            // Sign in with custom token or anonymously
            if (initialAuthToken) {
                await signInWithCustomToken(auth, initialAuthToken);
            } else {
                await signInAnonymously(auth);
            }
            
            // Set userId after successful sign in
            userId = auth.currentUser?.uid;
            
            // Listen for high score updates
            onSnapshot(doc(db, HIGH_SCORE_DOC_PATH), (docSnap) => {
                if (docSnap.exists()) {
                    const data = docSnap.data();
                    highScore = data.score || 0;
                    highScoreEl.textContent = highScore;
                }
            }, (error) => {
                console.error("Error listening to high score:", error);
            });

        } catch (error) {
            console.error("Firebase initialization or authentication failed:", error);
        }
    }

    async function saveHighScore(newScore) {
        if (!db) {
            console.log("Saving high score to localStorage.");
            localStorage.setItem('flappyHighScore', newScore);
            return;
        }

        const scoreRef = doc(db, HIGH_SCORE_DOC_PATH);
        
        try {
            // Check current high score atomically
            const docSnap = await getDoc(scoreRef);
            let currentBestScore = 0;
            if (docSnap.exists()) {
                currentBestScore = docSnap.data().score || 0;
            }

            if (newScore > currentBestScore) {
                // Use setDoc with merge to ensure no other data is overwritten
                await setDoc(scoreRef, { score: newScore, userId: userId, updated: new Date().toISOString() }, { merge: true });
                console.log("New high score saved to Firestore!");
            }
        } catch (error) {
            console.error("Error saving high score to Firestore:", error);
        }
    }

    // Initialize Firebase and set initial high score text
    initializeFirebase();

</script>

</body>
</html>